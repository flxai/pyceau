#!/usr/bin/env python3
# Game of life with different rules
import argparse
import copy
import os
import random
import shutil
import signal
import sys
import time

from PIL import Image, ImageDraw, ImageFont

def handler(signal, frame):
    if not args.no_recover and not args.quiet:
        print('\nTo recover from this configuration, use the following representation as additional parameter:\n')
        print(board.board_serialize(prefix_param=True))
    sys.exit(0)


class Board():
    def __init__(self, w, h, rule_string, tiles, subtitle_format, flicker_mode=0, tick=0, random_state=True,
                 state=False, seed='-1', max_ticks=None, spans_render_image=None, image_dir=None,
                 image_format=None, image_zoom=None, font_size=None, font_path=None, fill_percentage=0.5,
                 render_ticks=1):
        self.w = w
        self.h = h
        self.rules, self.rule_string = Board.parse_rules(rule_string)
        self.board = [[0] * self.w for i in range(self.h)]
        self.tiles = {
            0: tiles[0],
            1: tiles[1],
        }
        self.fill_percentage = fill_percentage
        if not state:
            if seed == '-1':
                seed = ''.join(random.sample([chr(i + 65) for i in list(range(26))], 5))
            self.seed = seed
            random.seed(self.seed)
        if state:
            self.board = state
            self.seed = '[custom]'
        elif random_state:
            self.init_random_state()
        self.flicker_mode = flicker_mode
        if flicker_mode > 3:
            self.flicker_mode = 0
        self.tick = tick
        self.max_ticks = max_ticks
        self.cells_alive_old = self.cells_alive
        self.cells_dead_old = self.cells_total - self.cells_alive_old
        if spans_render_image:
            self.ticks_render_image = self.parse_ranges(spans_render_image)
        else:
            self.ticks_render_image = None
        self.image_dir = image_dir
        try:
            os.mkdir(self.image_dir)
        except FileExistsError:
            pass
        self.subtitle_format = subtitle_format
        self.image_format = image_format
        self.image_zoom = int(image_zoom)
        self.font_size = font_size
        self.font_path = font_path
        self.font = ImageFont.truetype(self.font_path, self.font_size)
        self.render_ticks = render_ticks

    def init_random_state(self):
        for y in range(self.h):
            for x in range(self.w):
                self.board[y][x] = 1 if random.random() > self.fill_percentage else 0

    def draw(self, invert=False):
        if self.tick % self.render_ticks != 0:
            return
        inverted = self.inverted
        for y in range(self.h):
            for x in range(self.w):
                if not inverted:
                    print(self.tiles[self.board[y][x]], end='')
                else:
                    print(self.tiles[1 - self.board[y][x]], end='')
            print()
        print()
        if board.subtitle:
            print(board.subtitle)

    def step(self):
        board_next = copy.deepcopy(self.board)
        for y in range(self.h):
            for x in range(self.w):
                n = self.neighbours(x, y)
                alive = self.board[y][x]
                flip_alive, flip_dead = self.rules[n]
                if not alive and flip_dead:
                    board_next[y][x] = 1
                if alive and flip_alive:
                    board_next[y][x] = 0
        self.board = board_next
        self.tick += 1
        self.render_image()

    def neighbours(self, x_cen, y_cen):
        s = 0
        for y in range(y_cen - 1, y_cen + 2):
            while y < 0:
                y += self.h
            if y > self.h - 1:
                y %= self.h
            for x in range(x_cen - 1, x_cen + 2):
                if x == x_cen and y == y_cen:
                    continue
                while x < 0:
                    x += self.w
                if x > self.w - 1:
                    x %= self.w
                if self.board[y][x]:
                    s += 1
        return s

    def board_serialize(self, prefix_param=False):
        if prefix_param:
            board_serial = '-b '
        else:
            board_serial = ''
        for y in range(self.h):
            for x in range(self.w):
                board_serial += str(self.board[y][x])
            board_serial += '.'
        return board_serial

    def __str__(self):
        return self.subtitle

    def render_image(self):
        if not self.ticks_render_image or self.tick not in self.ticks_render_image:
            return
        image_file = self.parse_format(self.image_format)
        image_path = f'{self.image_dir}/{image_file}'
        z = self.image_zoom
        offset = 0 if args.no_subtitle else self.font_size
        im = Image.new('1', (self.w * z, self.h * z + offset), 0)
        draw = ImageDraw.Draw(im)
        inverted = self.inverted
        for y in range(self.h):
            for x in range(self.w):
                if inverted and not self.board[y][x] or (not inverted and self.board[y][x]):
                    draw.rectangle([(x * z, y * z), ((x + 1) * z - 1, (y + 1) * z - 1)], 1)
        if not args.no_subtitle:
            draw.text([0, (self.h) * z - self.font_size / 4], self.subtitle, 1, font=self.font)
        del draw
        im.save(image_path)

    def parse_ranges(self, ranges_str):
        ranges = [e.split(':') for e in ranges_str.split(',')]
        ranges_rollout = []
        for r in ranges:
            r = [int(e) for e in r]  # typecast
            if self.max_ticks > 0:
                r = [e % (self.max_ticks + 1) if e < 0 else e for e in r]  # wrap negative
            else:
                if True in [e < 0 for e in r]:
                    print('Negative ranges are only allowed if max ticks is given.')
                    sys.exit(1)
            if len(r) > 2:  # range w/ stepsize
                ranges_rollout += list(range(r[0], r[1] + 1, r[2]))
            elif len(r) > 1:  # range
                ranges_rollout += list(range(r[0], r[1] + 1))
            else:  # single tick
                ranges_rollout += [int(r[0])]
        return ranges_rollout

    def parse_format(self, fmt):
        if not fmt:
            return None
        seed = self.seed
        for s in ['[', ']']:
            seed = seed.replace(s, '')
        s = {  # sequences
            'r': self.rule_string,
            'R': self.rule_string.replace('/', '-'),
            'd': f'{self.w}x{self.h}',
            'D': f'{self.w}-{self.h}',
            'f': self.flicker_mode,
            'a': 'X' if self.flicker_mode == 0 else chr(self.flicker_mode + 64),
            's': self.seed,
            'S': seed,
            't': self.tick,
            'T': f'{self.tick:08}',
            'i': 'i' if self.inverted else ' ',
            'o': 's' if self.ticks_render_image and self.tick in self.ticks_render_image else ' ',
        }
        for k in s.keys():
            fmt = fmt.replace(f'%{k}', f'{{{k}}}')
        return fmt.format(**s)

    @ property
    def inverted(self):
        if self.flicker_mode == 0:
            return 0
        elif self.flicker_mode == 3:
            if self.tick % 2 == 0:
                return True
            else:
                return False
        invert = False
        cells_alive = self.cells_alive
        cells_dead = self.cells_total - cells_alive
        if self.flicker_mode == 1:
            corr_false = self.cells_alive_old - cells_dead
        elif self.flicker_mode == 2:
            corr_false = self.cells_dead_old - cells_dead
        # TODO: Use (board_old XOR board_now)'s count of 1s?
        else:
            corr_false = 0
        corr_true = self.cells_alive_old - cells_alive
        if corr_false > corr_true:
            invert = True
        self.cells_alive_old = cells_alive
        self.cells_dead_old = cells_dead
        return invert

    @property
    def cells_alive(self):
        alive = 0
        for y in range(self.h):
            for x in range(self.w):
                if self.board[y][x]:
                    alive += 1
        return alive

    @property
    def cells_total(self):
        return self.w * self.h

    @property
    def subtitle(self):
        return self.parse_format(self.subtitle_format)

    @staticmethod
    def parse_state(state_string):
        state = []
        for line in state_string.split('.'):
            state.append([int(c) for c in line])
        return state

    @staticmethod
    def random_rules(l_min=1, l_max=8, r_min=1, r_max=8):
        choices = list(range(8))
        l_num = random.randrange(l_min, l_max)
        r_num = random.randrange(r_min, r_max)
        l = sorted(random.sample(choices, l_num))
        r = sorted(random.sample(choices, r_num))
        l_str = "".join([str(e) for e in l])
        r_str = "".join([str(e) for e in r])
        rule_string = f'{l_str}/{r_str}'
        return rule_string

    @staticmethod
    def parse_rules(rule_string):
        rules = {i: [True, False] for i in range(9)}
        if '+' in rule_string:
            rule_tmp = rule_string.split('+')
            rule_string = Board.random_rules(
                    int(rule_tmp[0][0]),
                    int(rule_tmp[0][1]),
                    int(rule_tmp[1][0]),
                    int(rule_tmp[1][1]),
            )
        flip_alive, flip_dead = rule_string.split('/')
        for i in flip_alive:
            rules[int(i)][0] = False
        for i in flip_dead:
            rules[int(i)][1] = True
        return rules, rule_string


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Game of life with different rules', add_help=False)
    parser.add_argument('-?', '--help', action='store_true', help='Show this help message and exit')
    parser.add_argument('-q', '--quiet', help='Disable printing to stdout. Implies -c', action='store_true')
    parser.add_argument('-t', '--sleep', help='Time in seconds to sleep between each game tick. Default is to not sleep',
                        type=float, default=0)
    parser.add_argument('-l', '--tiles', help='String defining dead and alive cells', default='·█')
    parser.add_argument('-r', '--rules', help='Rules in S/B notation or L+R notation', default='23/3')
    group1 = parser.add_mutually_exclusive_group()
    group1.add_argument('-b', '--state', help='Set board state manually. See README.md for information on notation')
    group2 = group1.add_mutually_exclusive_group()
    group2.add_argument('--random', help='Initialize board randomly',
                       action='store_true')
    group2.add_argument('-d', '--dimensions', help='Dimensions of the board (5x5, MxM)', default='MxM')
    parser.add_argument('-s', '--max-ticks', help='Run only a specified amount of ticks.', default=-1, type=int)
    parser.add_argument('--render-ticks', help='Only render every nth tick', default=1, type=int)
    parser.add_argument('-m', '--flicker-mode', help='Flicker detection mode', default=0, type=int)
    parser.add_argument('-c', '--no-recover', help='No serialization when killed via SIGINT', action='store_true')
    parser.add_argument('-u', '--no-subtitle', help='Disables the subtitle bar', action='store_true')
    parser.add_argument('-f', '--subtitle-format', help='Sets subtitle\'s format. See README.md for information on notation',
                        default='%r %d %s %a%i %t%o')
    parser.add_argument('-e', '--seed', help='Set random seed to be used in PRNG', default='-1')
    parser.add_argument('-i', '--images', help='Render these tick spans to images. See README.md for information on notation',
                        default=None)
    parser.add_argument('--image-dir', help='Directory to store rendered images in', default='img')
    parser.add_argument('--image-format', help='Sets rendered images\' filenames format. See README.md for information on notation',
                        default='%R-%D-%S-%a-%T.png')
    parser.add_argument('-z', '--image-zoom', help='Zoom factor used for rendering',
                        default=5)
    parser.add_argument('-o', '--font-path', help='Path to font file or name of font used when rendering images',
                        default='DroidSansMono', type=str)
    parser.add_argument('-p', '--fill-percentage', help='Factor from 0 to 1 giving the probability of a cell to be alive in the first tick',
                        default=0.5, type=float)
    parser.add_argument('--font-size', help='Size of font used when rendering images',
                        default=10, type=int)
    args = parser.parse_args()
    path_abs = os.path.abspath(__file__)
    bin_dir = os.path.dirname(path_abs)
    os.chdir(bin_dir)

    if args.help:
        parser.print_help()
        sys.exit(0)

    if args.state:
        state = Board.parse_state(args.state)
        h = len(state)
        w = len(state[0])
    else:
        h_mod = 2 if args.no_subtitle else 3
        state = False
        w, h = args.dimensions.split('x')
        col, lin = shutil.get_terminal_size()
        w = col if w == 'M' else int(w)
        h = lin - h_mod if h == 'M' else int(h)

    signal.signal(signal.SIGINT, handler)
    board = Board(w, h, args.rules, args.tiles, state=state, flicker_mode=args.flicker_mode, seed=args.seed,
                  max_ticks=args.max_ticks, spans_render_image=args.images, image_dir=args.image_dir,
                  subtitle_format=None if args.no_subtitle else args.subtitle_format,
                  image_format=args.image_format, image_zoom=args.image_zoom, font_path=args.font_path,
                  font_size=args.font_size, fill_percentage=args.fill_percentage,
                  render_ticks=args.render_ticks)
    if not args.quiet:
        board.draw()
    time.sleep(args.sleep)
    step = 1
    while True:
        board.step()
        if not args.quiet:
            board.draw()
            time.sleep(args.sleep)
        step += 1
        if args.max_ticks > 0 and step > args.max_ticks:
            board.render_image()
            sys.exit(0)
