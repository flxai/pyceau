#!/usr/bin/env python3
# Game of life with different rules
import argparse
import copy
import random
import shutil
import signal
import sys
import time


def handler(signal, frame):
    if not args.no_recover and not args.quiet:
        print('\nTo recover from this configuration, use the following representation as additional parameter:\n')
        print(board.board_serialize(prefix_param=True))
    sys.exit(0)


class Board():
    def __init__(self, w, h, rule_string, tiles, flicker_mode=0, tick=0, random_state=True, state=False,
                 subtitle_format='%r %d %s %a%i %t', seed='-1'):
        self.w = w
        self.h = h
        self.rules, self.rule_string = Board.parse_rules(rule_string)
        self.board = [[0] * self.w for i in range(self.h)]
        self.tiles = {
            0: tiles[0],
            1: tiles[1],
        }
        if seed == '-1':
            seed = ''.join(random.sample([chr(i + 65) for i in list(range(26))], 5))
        self.seed = seed
        random.seed(self.seed)
        if state:
            self.board = state
        elif random_state:
            self.init_random_state()
        self.flicker_mode = flicker_mode
        if flicker_mode > 3:
            self.flicker_mode = 0
        self.tick = tick
        self.subtitle_format = subtitle_format
        sequences = ['r', 'd', 'f', 's', 'a', 'i', 't']
        for k in sequences:
            self.subtitle_format = self.subtitle_format.replace(f'%{k}', f'{{{k}}}')

    def init_random_state(self):
        for y in range(self.h):
            for x in range(self.w):
                self.board[y][x] = random.randint(0, 1)

    def draw(self, invert=False):
        for y in range(self.h):
            for x in range(self.w):
                if not invert:
                    print(self.tiles[self.board[y][x]], end='')
                else:
                    print(self.tiles[1 - self.board[y][x]], end='')
            print()
        print()

    def step(self):
        board_next = copy.deepcopy(self.board)
        for y in range(self.h):
            for x in range(self.w):
                n = self.neighbours(x, y)
                alive = self.board[y][x]
                flip_alive, flip_dead = self.rules[n]
                if not alive and flip_dead:
                    board_next[y][x] = 1
                if alive and flip_alive:
                    board_next[y][x] = 0
        self.board = board_next
        self.tick += 1

    def neighbours(self, x_cen, y_cen):
        s = 0
        for y in range(y_cen - 1, y_cen + 2):
            while y < 0:
                y += self.h
            if y > self.h - 1:
                y %= self.h
            for x in range(x_cen - 1, x_cen + 2):
                if x == x_cen and y == y_cen:
                    continue
                while x < 0:
                    x += self.w
                if x > self.w - 1:
                    x %= self.w
                if self.board[y][x]:
                    s += 1
        return s

    def board_serialize(self, prefix_param=False):
        if prefix_param:
            board_serial = '-b '
        else:
            board_serial = ''
        for y in range(self.h):
            for x in range(self.w):
                board_serial += str(self.board[y][x])
            board_serial += '.'
        return board_serial

    @ property
    def inverted(self):
        return False
        if self.flicker_mode > 0:
            invert = False
            alive_old = alive
            dead_old = dead
            alive = board.cells_alive
            dead = total - alive
            if args.flicker_mode == 1:
                corr_false = alive_old - dead
            elif args.flicker_mode == 2:
                corr_false = dead_old - dead
            elif args.flicker_mode == 3:
                corr_false = int(random.random() * 1E9)
            # TODO: Use (board_old XOR board_now)'s count of 1s?
            else:
                corr_false = 0
            corr_true = alive_old - alive
            if corr_false > corr_true:
                invert = True
        return invert

    @property
    def cells_alive(self):
        alive = 0
        for y in range(self.h):
            for x in range(self.w):
                if self.board[y][x]:
                    alive += 1
        return alive

    @property
    def cells_total(self):
        return self.w * self.h

    @property
    def subtitle(self):
        s = {  # sequences
            'r': self.rule_string,
            'd': f'{self.w}x{self.h}',
            'f': self.flicker_mode,
            's': f'{self.seed}',
            'a': 'X' if self.flicker_mode == 0 else chr(self.flicker_mode + 64),
            't': self.tick,
            'i': 'i' if self.inverted else ' ',
        }
        return self.subtitle_format.format(**s)

    @staticmethod
    def parse_state(state_string):
        state = []
        for line in state_string.split('.'):
            state.append([int(c) for c in line])
        return state

    @staticmethod
    def random_rules(l_min=1, l_max=8, r_min=1, r_max=8):
        choices = list(range(8))
        l_num = random.randrange(l_min, l_max)
        r_num = random.randrange(r_min, r_max)
        l = sorted(random.sample(choices, l_num))
        r = sorted(random.sample(choices, r_num))
        l_str = "".join([str(e) for e in l])
        r_str = "".join([str(e) for e in r])
        rule_string = f'{l_str}/{r_str}'
        return rule_string

    @staticmethod
    def parse_rules(rule_string):
        rules = {i: [True, False] for i in range(9)}
        if '+' in rule_string:
            rule_tmp = rule_string.split('+')
            rule_string = Board.random_rules(
                    int(rule_tmp[0][0]),
                    int(rule_tmp[0][1]),
                    int(rule_tmp[1][0]),
                    int(rule_tmp[1][1]),
            )
        flip_alive, flip_dead = rule_string.split('/')
        for i in flip_alive:
            rules[int(i)][0] = False
        for i in flip_dead:
            rules[int(i)][1] = True
        return rules, rule_string


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Game of life with different rules', add_help=False)
    parser.add_argument('-?', '--help', action='store_true', help='Show this help message and exit')
    parser.add_argument('-q', '--quiet', help='Disable printing to stdout. Implies -c', action='store_true')
    parser.add_argument('-t', '--sleep', help='Time in seconds to sleep between each game tick. Default is to not sleep',
                        type=float, default=0)
    parser.add_argument('-l', '--tiles', help='String defining dead and alive cells', default='·█')
    parser.add_argument('-r', '--rules', help='Rules in S/B notation or L+R notation', default='23/3')
    group1 = parser.add_mutually_exclusive_group()
    group1.add_argument('-b', '--state', help='Set board state manually. See README.md for information on notation')
    group2 = group1.add_mutually_exclusive_group()
    group2.add_argument('--random', help='Initialize board randomly',
                       action='store_true')
    group2.add_argument('-d', '--dimensions', help='Dimensions of the board (5x5, MxM)', default='MxM')
    parser.add_argument('-s', '--steps', help='Run only a specified amount of steps/ticks.', default=-1, type=int)
    parser.add_argument('-m', '--flicker-mode', help='Flicker detection mode', default=0, type=int)
    parser.add_argument('-c', '--no-recover', help='No serialization when killed via SIGINT', action='store_true')
    parser.add_argument('-u', '--no-subtitle', help='Disables the subtitle bar', action='store_true')
    parser.add_argument('-f', '--subtitle-format', help='Sets subtitle\'s format. See README.md for information on notation')
    parser.add_argument('-e', '--seed', help='Set random seed to be used in PRNG', default='-1')
    args = parser.parse_args()

    if args.help:
        parser.print_help()
        sys.exit(0)

    if args.state:
        state = Board.parse_state(args.state)
        h = len(state)
        w = len(state[0])
    else:
        h_mod = 2 if args.no_subtitle else 3
        state = False
        w, h = args.dimensions.split('x')
        col, lin = shutil.get_terminal_size()
        w = col if w == 'M' else int(w)
        h = lin - h_mod if h == 'M' else int(h)

    signal.signal(signal.SIGINT, handler)
    board = Board(w, h, args.rules, args.tiles, state=state, flicker_mode=args.flicker_mode, seed=args.seed)
    if not args.quiet:
        board.draw()
        if not args.no_subtitle:
            print(board.subtitle)
    time.sleep(args.sleep)
    step = 1
    while True:
        board.step()
        if not args.quiet:
            board.draw()
            if not args.no_subtitle:
                print(board.subtitle)
            time.sleep(args.sleep)
        step += 1
        if args.steps > 0 and step > args.steps:
            sys.exit(0)
