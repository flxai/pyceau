#!/usr/bin/env python3
# Game of life with different rules
import argparse
import copy
import random
import shutil
import signal
import sys
import time


def handler(signal, frame):
    print()
    if not args.no_recover:
        print('To recover from this configuration, use the following representation as additional parameter:\n')
        print(board.board_serialize(prefix_param=True))
    sys.exit(0)


class Board():
    def __init__(self, w, h, rules, tiles, random=True, state=False):
        self.w = w
        self.h = h
        self.rules = rules
        self.board = [[0] * self.w for i in range(self.h)]
        self.tiles = {
            0: tiles[0],
            1: tiles[1],
        }
        if state:
            self.board = state
        elif random:
            self.init_random()

    def init_random(self):
        for y in range(self.h):
            for x in range(self.w):
                self.board[y][x] = random.randint(0, 1)

    def draw(self, invert=False):
        for y in range(self.h):
            for x in range(self.w):
                if not invert:
                    print(self.tiles[self.board[y][x]], end='')
                else:
                    print(self.tiles[1 - self.board[y][x]], end='')
            print()
        print()

    def step(self):
        board_next = copy.deepcopy(self.board)
        for y in range(self.h):
            for x in range(self.w):
                n = self.neighbours(x, y)
                alive = self.board[y][x]
                flip_alive, flip_dead = self.rules[n]
                if not alive and flip_dead:
                    board_next[y][x] = 1
                if alive and flip_alive:
                    board_next[y][x] = 0
        self.board = board_next

    def neighbours(self, x_cen, y_cen):
        s = 0
        for y in range(y_cen - 1, y_cen + 2):
            while y < 0:
                y += self.h
            if y > self.h - 1:
                y %= self.h
            for x in range(x_cen - 1, x_cen + 2):
                if x == x_cen and y == y_cen:
                    continue
                while x < 0:
                    x += self.w
                if x > self.w - 1:
                    x %= self.w
                if self.board[y][x]:
                    s += 1
        return s

    def board_serialize(self, prefix_param=False):
        if prefix_param:
            board_serial = '-b '
        else:
            board_serial = ''
        for y in range(self.h):
            for x in range(self.w):
                board_serial += str(self.board[y][x])
            board_serial += '.'
        return board_serial

    @property
    def cells_alive(self):
        alive = 0
        for y in range(self.h):
            for x in range(self.w):
                if self.board[y][x]:
                    alive += 1
        return alive

    @property
    def cells_total(self):
        return self.w * self.h

    @staticmethod
    def parse_state(state_string):
        state = []
        for line in state_string.split('.'):
            state.append([int(c) for c in line])
        return state

    @staticmethod
    def random_rules(l_min=1, l_max=8, r_min=1, r_max=8):
        choices = list(range(8))
        l_num = random.randrange(l_min, l_max)
        r_num = random.randrange(r_min, r_max)
        l = sorted(random.sample(choices, l_num))
        r = sorted(random.sample(choices, r_num))
        l_str = "".join([str(e) for e in l])
        r_str = "".join([str(e) for e in r])
        rule_string = f'{l_str}/{r_str}'
        return rule_string

    @staticmethod
    def parse_rules(rule_string='23/3'):
        rules = {i: [True, False] for i in range(9)}
        if '+' in rule_string:
            rule_tmp = rule_string.split('+')
            rule_string = Board.random_rules(
                    int(rule_tmp[0][0]),
                    int(rule_tmp[0][1]),
                    int(rule_tmp[1][0]),
                    int(rule_tmp[1][1]),
            )
        flip_alive, flip_dead = rule_string.split('/')
        for i in flip_alive:
            rules[int(i)][0] = False
        for i in flip_dead:
            rules[int(i)][1] = True
        return rules, rule_string


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Game of life with different rules', add_help=False)
    parser.add_argument('--help', action='store_true', help='Show this help message and exit')
    parser.add_argument('-s', '--sleep', help='Time to sleep between each game tick. Default is .04s',
                        type=float, default=.04)
    parser.add_argument('-t', '--tiles', help='String defining dead and alive cells', default='·█')
    parser.add_argument('-r', '--rules', help='Rules in S/B notation or L+R notation', default='23/3')
    group1 = parser.add_mutually_exclusive_group()
    group1.add_argument('-b', '--state', help='Set board state manually. See README.md for information on notation')
    group2 = group1.add_mutually_exclusive_group()
    group2.add_argument('--random', help='Initialize board randomly',
                       action='store_true')
    group2.add_argument('-d', '--dimensions', help='Dimensions of the board (5x5, MxM)', default='MxM')
    parser.add_argument('--steps', help='Run only a specified amount of steps/ticks.', default=-1, type=int)
    parser.add_argument('-p', '--flicker-protect', help='Try to minimize flicker', action='store_true')
    parser.add_argument('-m', '--flicker-mode', help='Flicker detection mode', default=1, type=int)
    parser.add_argument('-c', '--no-recover', help='No serialization when killed via SIGINT', action='store_true')
    args = parser.parse_args()

    if args.help:
        parser.print_help()
        sys.exit(0)

    rules, rule_string = Board.parse_rules(args.rules)
    if args.state:
        state = Board.parse_state(args.state)
        h = len(state)
        w = len(state[0])
    else:
        state = False
        w, h = args.dimensions.split('x')
        col, lin = shutil.get_terminal_size()
        w = col if w == 'M' else int(w)
        h = lin - 2 if h == 'M' else int(h)

    signal.signal(signal.SIGINT, handler)
    board = Board(w, h, rules, args.tiles, state=state)
    if args.flicker_protect:
        total = board.cells_total
        alive = 0
        dead = total - alive
    board.draw()
    print(rule_string, chr(args.flicker_mode + 64), 0)
    time.sleep(args.sleep)
    invert = False
    step = 1
    while True:
        if args.flicker_protect:
            invert = False
            alive_old = alive
            dead_old = dead
            alive = board.cells_alive
            dead = total - alive
            if args.flicker_mode == 1:
                corr_false = alive_old - dead
            elif args.flicker_mode == 2:
                corr_false = dead_old - dead
            # TODO: Use (board_old XOR board_now)'s count of 1s?
            else:
                corr_false = 0
            corr_true = alive_old - alive
            if corr_false > corr_true:
                invert = True
        board.step()
        board.draw(invert=invert)
        print(rule_string, chr(args.flicker_mode + 64), step, 'i' if invert else '')
        time.sleep(args.sleep)
        step += 1
        if args.steps > 0 and step > args.steps:
            sys.exit(0)
